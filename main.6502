\ ******************************************************************
\ * SQUEEKER PLUS 6502 - FULL IMPLEMENTATION (CYCLE-TIMED)        *
\ * Ported from Utz's Z80 Engine / 1Tracker Shiru Version          *
\ ******************************************************************

\ --- Debug Flag ---
DEBUG = FALSE            \ Set to FALSE to disable debug output

\ --- Hardware Registers ---
VIA_ORA     = $FE41     \ Data
VIA_ORB     = $FE40     \ Control (PB3=WE)
SN_LOUD     = $90       \ Ch0 Vol 0
SN_MUTE     = $9F       \ Ch0 Vol 15

\ --- Timing Constants ---
\ Target: ~312 scanlines * 64 cycles = 19,968 cycles per frame (PAL 50Hz)
\ The synth loop must be cycle-exact to generate correct audio frequency

\ --- Zero Page State ---
ORG 0
SKIP 112                \ Reserve 0-111 for system use

.seq_ptr     SKIP 2     \ Points to the list of patterns (the Song)
.row_timer   SKIP 1     \ Frame counter for current row
.frame_count SKIP 2     \ Inner loop counter for sample generation
.tmp_mix     SKIP 1
.ctrl_a      SKIP 1
.ctrl_b      SKIP 1
.pat_ptr     SKIP 2     \ Points to the actual notes (the Pattern)
IF DEBUG
.debug_row   SKIP 1     \ Row counter for debug
ENDIF

\ Channel Blocks: 16-bit Freq, 16-bit Acc, 16-bit EnvPtr, 8-bit Duty
.ch1_f SKIP 2 : .ch1_a SKIP 2 : .ch1_e SKIP 2 : .ch1_d SKIP 1 : .ch1_n SKIP 1
.ch2_f SKIP 2 : .ch2_a SKIP 2 : .ch2_e SKIP 2 : .ch2_d SKIP 1 : .ch2_n SKIP 1
.ch3_f SKIP 2 : .ch3_a SKIP 2 : .ch3_e SKIP 2 : .ch3_d SKIP 1
.ch4_f SKIP 2 : .ch4_a SKIP 2 : .ch4_e SKIP 2 : .ch4_d SKIP 1 : .ch4_s SKIP 1

ORG $1100
.start
IF DEBUG
    LDA #22 : JSR $FFF4     \ Mode 7
    LDA #12 : JSR $FFF4     \ CLS
ENDIF
    
    SEI
    JSR init_hw
    
IF DEBUG
    LDA #0 : STA debug_row
ENDIF
    
    \ Start at the first pattern address in the sequence table (Offset +2)
    LDA #LO(music_data+2) : STA seq_ptr
    LDA #HI(music_data+2) : STA seq_ptr+1
    
    JSR fetch_new_pattern 
    JMP check_row

\ --- 1. SONG SEQUENCE LOGIC ---
.pattern_end
IF DEBUG
    \ Print "P.END" on screen
    LDA #'P' : JSR $FFEE
    LDA #'.' : JSR $FFEE
    LDA #'E' : JSR $FFEE
    LDA #'N' : JSR $FFEE
    LDA #'D' : JSR $FFEE
    LDA #' ' : JSR $FFEE
ENDIF
    
    LDA seq_ptr : CLC : ADC #2 : STA seq_ptr
    BCC p_next : INC seq_ptr+1
.p_next
    JSR fetch_new_pattern
    JMP check_row

\ --- 2. PATTERN READER ---
.check_row
IF DEBUG
    \ Print row counter
    INC debug_row
    LDA debug_row
    JSR print_hex
    LDA #':' : JSR $FFEE
    LDA #' ' : JSR $FFEE
    
    \ Print pattern pointer
    LDA pat_ptr+1 : JSR print_hex
    LDA pat_ptr : JSR print_hex
    LDA #' ' : JSR $FFEE
ENDIF
    
    LDY #0
    LDA (pat_ptr),Y 
    
IF DEBUG
    \ Print first byte
    JSR print_hex
    LDA #' ' : JSR $FFEE
ENDIF
    
    INY
    CMP #$40
    BEQ pattern_end

.rdseq
    DEY                                   ; Back to Y=0
    LDA (pat_ptr),Y : INY                 ; Low byte (flags)
    STA ctrl_a
    LDA (pat_ptr),Y : INY                 ; High byte (SPEED)
    STA row_timer                         ; Number of frames to play this row
    
IF DEBUG
    \ Print speed
    LDA row_timer : JSR print_hex
    LDA #13 : JSR $FFEE     ; Newline
ENDIF
    
    LDA (pat_ptr),Y : STA ch2_n : INY     ; Noise low
    LDA (pat_ptr),Y : STA ch1_n : INY     ; Noise high

    \ --- Channel 1 Update ---
    LDA ctrl_a : LSR A : BCS ld2
    LDA (pat_ptr),Y : STA ch1_f : INY
    LDA (pat_ptr),Y : STA ch1_f+1 : INY
    LDA (pat_ptr),Y : STA ch1_e : INY
    LDA (pat_ptr),Y : STA ch1_e+1 : INY
    LDA #0 : STA ch1_a : STA ch1_a+1
    STY tmp_mix : LDY #0 : LDA (ch1_e),Y : STA ch1_d : LDY tmp_mix
.ld2
    \ --- Channel 2 Update ---
    LDA ctrl_a : AND #4 : BNE ld3
    LDA (pat_ptr),Y : STA ch2_f : INY
    LDA (pat_ptr),Y : STA ch2_f+1 : INY
    LDA (pat_ptr),Y : STA ch2_e : INY
    LDA (pat_ptr),Y : STA ch2_e+1 : INY
    LDA #0 : STA ch2_a : STA ch2_a+1
    STY tmp_mix : LDY #0 : LDA (ch2_e),Y : STA ch2_d : LDY tmp_mix
.ld3
    \ --- Channel 3 Update ---
    BIT ctrl_a : BMI ld4
    LDA (pat_ptr),Y : STA ch3_f : INY
    LDA (pat_ptr),Y : STA ch3_f+1 : INY
    LDA (pat_ptr),Y : STA ch3_e : INY
    LDA (pat_ptr),Y : STA ch3_e+1 : INY
    LDA #0 : STA ch3_a : STA ch3_a+1
    STY tmp_mix : LDY #0 : LDA (ch3_e),Y : STA ch3_d : LDY tmp_mix
.ld4
    \ --- Channel 4 Update ---
    LDA (pat_ptr),Y : STA ctrl_b : INY    ; Low byte of control word B
    INY                                    ; Skip high byte (always 0)
    LDA ctrl_b : AND #$40 : BNE skip4
    LDA (pat_ptr),Y : STA ch4_f : INY
    LDA (pat_ptr),Y : STA ch4_f+1 : INY
    LDA (pat_ptr),Y : STA ch4_e : INY
    LDA (pat_ptr),Y : STA ch4_e+1 : INY
    LDA #0 : STA ch4_a : STA ch4_a+1
    STY tmp_mix : LDY #0 : LDA (ch4_e),Y : STA ch4_d : LDY tmp_mix
.skip4
    LDA ctrl_b : AND #1 : STA ch4_s

    \ --- Advance Pattern Pointer by bytes read (Y) ---
    TYA : CLC : ADC pat_ptr : STA pat_ptr
    BCC p_adv : INC pat_ptr+1
.p_adv
    \ Initialize frame counter for one complete frame
    LDA #<19968 : STA frame_count       ; Low byte of cycles per frame
    LDA #>19968 : STA frame_count+1     ; High byte
    \ Fall through to synth_loop

\ --- 3. CYCLE-TIMED SYNTHESIS LOOP ---
\ This loop generates audio samples for ONE FRAME (1/50th second)
\ It must repeat the sample generation enough times to fill the frame
.synth_loop
    \ Generate one sample by mixing all 4 channels
    CLC : LDA ch1_a : ADC ch1_f : STA ch1_a         ; 11 cycles
    LDA ch1_a+1 : ADC ch1_f+1 : STA ch1_a+1         ; 11 cycles
    LDX ch1_n : BEQ skip_n1 : ROR ch1_a+1           ; 7 cycles
.skip_n1
    CMP ch1_d : LDA #0 : ROL A : STA tmp_mix        ; 11 cycles

    CLC : LDA ch2_a : ADC ch2_f : STA ch2_a         ; 11 cycles
    LDA ch2_a+1 : ADC ch2_f+1 : STA ch2_a+1         ; 11 cycles
    LDX ch2_n : BEQ skip_n2 : ROR ch2_a+1           ; 7 cycles
.skip_n2
    CMP ch2_d : LDA #0 : ROL A : ORA tmp_mix : STA tmp_mix  ; 14 cycles

    CLC : LDA ch3_a : ADC ch3_f : STA ch3_a         ; 11 cycles
    LDA ch3_a+1 : ADC ch3_f+1 : STA ch3_a+1         ; 11 cycles
    CMP ch3_d : LDA #0 : ROL A : ORA tmp_mix : STA tmp_mix  ; 14 cycles

    CLC : LDA ch4_a : ADC ch4_f : STA ch4_a         ; 11 cycles
    LDA ch4_a+1 : ADC ch4_f+1 : STA ch4_a+1         ; 11 cycles
    CMP ch4_d : LDA #0 : ROL A : ORA tmp_mix        ; 11 cycles

    BNE do_loud                                      ; 2-3 cycles
    LDA #SN_MUTE : JMP send_sn                      ; 5 cycles
.do_loud
    LDA #SN_LOUD : NOP                              ; 4 cycles
.send_sn
    STA VIA_ORA                                      ; 4 cycles
    LDX #0 : STX VIA_ORB                            ; 7 cycles
    LDX #8 : STX VIA_ORB                            ; 7 cycles

    \ Brief settling delay for SN76489 (tuned to make loop exact timing)
    LDX #11                                          ; 2 cycles
.pad_loop 
    DEX : BNE pad_loop                              ; 33 cycles (11*3)
    NOP : NOP : NOP : NOP                           ; 8 cycles
    
    \ Total loop: ~200 cycles per sample
    \ Decrement frame counter
    LDA frame_count : SEC : SBC #<200 : STA frame_count      ; 11 cycles
    LDA frame_count+1 : SBC #>200 : STA frame_count+1        ; 11 cycles
    BCC skip_this
    JMP synth_loop                                           ; 3 cycles
.skip_this
    \ Frame complete - update envelopes and check row timer
    JMP update_timer

\ --- 4. ENVELOPE & SLIDE UPDATE (Once per frame) ---
.update_timer
    \ Update envelope pointers for all channels
    INC ch1_e : BNE e1 : INC ch1_e+1
.e1 LDY #0 : LDA (ch1_e),Y : CMP #$80 : BEQ e2 : STA ch1_d
.e2 INC ch2_e : BNE e2_skip : INC ch2_e+1
.e2_skip LDY #0 : LDA (ch2_e),Y : CMP #$80 : BEQ e3 : STA ch2_d
.e3 INC ch3_e : BNE e3_skip : INC ch3_e+1
.e3_skip LDY #0 : LDA (ch3_e),Y : CMP #$80 : BEQ e4 : STA ch3_d
.e4 INC ch4_e : BNE e4_skip : INC ch4_e+1
.e4_skip LDY #0 : LDA (ch4_e),Y : CMP #$80 : BEQ slide_proc : STA ch4_d

.slide_proc
    \ Apply pitch slide effect to channel 4
    LDA ch4_s : BEQ noslide
    LDA ch4_f+1 : LSR A : TAX
    LDA ch4_f   : ROR A : TAY
    SEC : LDA ch4_f : STY tmp_mix : SBC tmp_mix : STA ch4_f
    LDA ch4_f+1 : STX tmp_mix : SBC tmp_mix : STA ch4_f+1
.noslide
    \ Check if we need to advance to next row
    DEC row_timer           ; Decrement frame counter
    BNE play_same_row       ; If not zero, play same row again
    JMP check_row           ; If zero, read next row

.play_same_row
    \ Reload frame counter and play another frame of same row
    LDA #<19968 : STA frame_count
    LDA #>19968 : STA frame_count+1
    JMP synth_loop

.fetch_new_pattern
    LDY #0
    LDA (seq_ptr),Y : STA pat_ptr
    INY
    LDA (seq_ptr),Y : STA pat_ptr+1
    
    \ Check for end of sequence (NULL pointer = loop)
    LDA pat_ptr : ORA pat_ptr+1 : BNE fetch_done
    
IF DEBUG
    \ Loop back to start
    LDA #'L' : JSR $FFEE
    LDA #'O' : JSR $FFEE
    LDA #'O' : JSR $FFEE
    LDA #'P' : JSR $FFEE
    LDA #13 : JSR $FFEE
    
    LDA #0 : STA debug_row  ; Reset counter on loop
ENDIF
    
    \ Loop: reload sequence pointer from music data header
    LDA music_data : STA seq_ptr
    LDA music_data+1 : STA seq_ptr+1
    JMP fetch_new_pattern
.fetch_done
    RTS

IF DEBUG
\ Print A as hex
.print_hex
    PHA
    LSR A : LSR A : LSR A : LSR A
    CMP #10 : BCC ph1
    ADC #6
.ph1 ADC #'0' : JSR $FFEE
    PLA : AND #15
    CMP #10 : BCC ph2
    ADC #6
.ph2 ADC #'0' : JSR $FFEE
    RTS
ENDIF

.init_hw
    \ Initialize SN76489: mute all channels
    LDA #$9F : JSR sn_w : LDA #$BF : JSR sn_w
    LDA #$DF : JSR sn_w : LDA #$FF : JSR sn_w
    \ Configure VIA for SN76489 control
    LDA #$FF : STA $FE43 : LDA #$0F : STA $FE42
    \ Set noise channel to periodic, mid-frequency
    LDA #$81 : JSR sn_w : LDA #$00 : JSR sn_w : RTS
.sn_w
    STA VIA_ORA : LDX #0 : STX VIA_ORB : LDX #8 : STX VIA_ORB : RTS

ORG $2000
    INCLUDE "tracks\Squeeker Plus\1-bit_high_and_rising.asm"
.end
SAVE "MAIN",start,end

\ ******************************************************************
\ *    Memory Info
\ ******************************************************************

PRINT "-------------------------------------"
PRINT "      1-BIT SQUEEKER PLUS PLAYER     "
PRINT "-------------------------------------"
PRINT "CODE size       = ", ~end-start
PRINT "-------------------------------------"
PRINT "HIGH WATERMARK  = ", ~P%
PRINT "FREE            = ", ~start+end
PRINT "-------------------------------------"

\ ******************************************************************
\ * Supporting Files
\ ******************************************************************

PUTBASIC "loader.bas","LOADER"
PUTFILE  "screens\title.bin","TITLE",&7c00
PUTFILE  "BOOT","!BOOT",$ffff