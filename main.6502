\ ******************************************************************
\ * SQUEEKER PLUS 6502 - OPTIMIZED FOR SPEED - DRUMS FIXED       *
\ * Fixed drum implementation to match Z80 reference             *
\ ******************************************************************

VIA_DDRA    = $FE43
VIA_DDRB    = $FE42
VIA_ORA     = $FE41
VIA_ORB     = $FE40
SN_LOUD     = $90
SN_MUTE     = $9F

SAMPLES_PER_FRAME = 290
SAMPLES_LO = SAMPLES_PER_FRAME AND 255
SAMPLES_HI = SAMPLES_PER_FRAME DIV 256

ORG 0

.seq_ptr        SKIP 2
.row_timer      SKIP 1
.sample_count   SKIP 2
.tmp_mix        SKIP 1
.ctrl_a         SKIP 1
.ctrl_b         SKIP 1
.pat_ptr        SKIP 2
.drum_flag      SKIP 1
.drum_index     SKIP 1
.drum_delay     SKIP 1
.drum_state     SKIP 1

.ch1_f          SKIP 2
.ch1_a          SKIP 2
.ch1_e          SKIP 2
.ch1_d          SKIP 1
.ch1_n          SKIP 1

.ch2_f          SKIP 2
.ch2_a          SKIP 2
.ch2_e          SKIP 2
.ch2_d          SKIP 1
.ch2_n          SKIP 1

.ch3_f          SKIP 2
.ch3_a          SKIP 2
.ch3_e          SKIP 2
.ch3_d          SKIP 1

.ch4_f          SKIP 2
.ch4_a          SKIP 2
.ch4_e          SKIP 2
.ch4_d          SKIP 1
.ch4_s          SKIP 1

ORG $1100
.start
    SEI
    JSR init_hw
    
    LDA #LO(music_data+2)
    STA seq_ptr
    LDA #HI(music_data+2)
    STA seq_ptr+1
    
    JSR fetch_new_pattern
    JMP check_row

.pattern_end 
    LDA seq_ptr
    CLC
    ADC #2
    STA seq_ptr
    BCC p_next
    INC seq_ptr+1
.p_next
    LDY #0
    LDA (seq_ptr),Y
    STA pat_ptr
    INY
    LDA (seq_ptr),Y
    STA pat_ptr+1
    
    LDA pat_ptr
    ORA pat_ptr+1
    BNE check_row
    
    LDA music_data
    STA seq_ptr
    LDA music_data+1
    STA seq_ptr+1
    JMP pattern_end

.check_row
    LDY #0
    LDA (pat_ptr),Y
    CMP #$40
    BEQ pattern_end

.rdseq
    LDA (pat_ptr),Y
    INY
    STA ctrl_a
    LDA (pat_ptr),Y
    INY
    STA row_timer
       
    LDA (pat_ptr),Y
    STA ch2_n
    INY
    LDA (pat_ptr),Y
    STA ch1_n
    INY

    LDA ctrl_a
    LSR A
    BCS ld2
    LDA (pat_ptr),Y
    STA ch1_f
    INY
    LDA (pat_ptr),Y
    STA ch1_f+1
    INY
    LDA (pat_ptr),Y
    STA ch1_e
    INY
    LDA (pat_ptr),Y
    STA ch1_e+1
    INY
    LDA #0
    STA ch1_a
    STA ch1_a+1
    STY tmp_mix
    LDY #0
    LDA (ch1_e),Y
    STA ch1_d
    LDY tmp_mix
.ld2
    LDA ctrl_a
    AND #4
    BNE ld3
    LDA (pat_ptr),Y
    STA ch2_f
    INY
    LDA (pat_ptr),Y
    STA ch2_f+1
    INY
    LDA (pat_ptr),Y
    STA ch2_e
    INY
    LDA (pat_ptr),Y
    STA ch2_e+1
    INY
    LDA #0
    STA ch2_a
    STA ch2_a+1
    STY tmp_mix
    LDY #0
    LDA (ch2_e),Y
    STA ch2_d
    LDY tmp_mix
.ld3
    BIT ctrl_a
    BMI ld4
    LDA (pat_ptr),Y
    STA ch3_f
    INY
    LDA (pat_ptr),Y
    STA ch3_f+1
    INY
    LDA (pat_ptr),Y
    STA ch3_e
    INY
    LDA (pat_ptr),Y
    STA ch3_e+1
    INY
    LDA #0
    STA ch3_a
    STA ch3_a+1
    STY tmp_mix
    LDY #0
    LDA (ch3_e),Y
    STA ch3_d
    LDY tmp_mix
.ld4
    LDA (pat_ptr),Y
    STA ctrl_b
    INY
    INY
    
    LDA #0
    STA drum_flag
    LDA ctrl_b
    AND #$04
    BEQ no_kick
    LDA #1
    STA drum_flag
    LDA #0
    STA drum_index
    STA drum_delay
    LDA #SN_MUTE
    STA drum_state
.no_kick
    LDA ctrl_b
    AND #$80
    BEQ no_hat
    LDA #2
    STA drum_flag
    LDA #0
    STA drum_index
    STA drum_delay
    LDA #SN_MUTE
    STA drum_state
.no_hat
    
    LDA ctrl_b
    AND #$40
    BNE skip4
    LDA (pat_ptr),Y
    STA ch4_f
    INY
    LDA (pat_ptr),Y
    STA ch4_f+1
    INY
    LDA (pat_ptr),Y
    STA ch4_e
    INY
    LDA (pat_ptr),Y
    STA ch4_e+1
    INY
    LDA #0
    STA ch4_a
    STA ch4_a+1
    STY tmp_mix
    LDY #0
    LDA (ch4_e),Y
    STA ch4_d
    LDY tmp_mix
.skip4
    LDA ctrl_b
    AND #1
    STA ch4_s

    TYA
    CLC
    ADC pat_ptr
    STA pat_ptr
    BCC p_adv
    INC pat_ptr+1
.p_adv
    LDA ch1_n
    BEQ ch1_no_noise_smc
    LDA #$2A            ; ROL A opcode (was $6A ROR - wrong direction!)
    STA ch1_noise_op
    LDA #$EA
    STA ch1_noise_op+1
    JMP ch2_smc
.ch1_no_noise_smc
    LDA #$EA
    STA ch1_noise_op
    STA ch1_noise_op+1
    
.ch2_smc
    LDA ch2_n
    BEQ ch2_no_noise_smc
    LDA #$2A            ; ROL A opcode (was $6A ROR - wrong direction!)
    STA ch2_noise_op
    LDA #$EA
    STA ch2_noise_op+1
    JMP start_synth
.ch2_no_noise_smc
    LDA #$EA
    STA ch2_noise_op
    STA ch2_noise_op+1
    
.start_synth
    LDA #SAMPLES_LO
    STA sample_count
    LDA #SAMPLES_HI
    STA sample_count+1
    CLC

.synth_loop
    LDA #0
    STA tmp_mix

    \ Channel 1 - inline phase accumulation
    LDA ch1_a
    ADC ch1_f
    STA ch1_a
    LDA ch1_a+1
    ADC ch1_f+1
    STA ch1_a+1
.ch1_noise_op
    NOP
    NOP
    ADC ch1_d
    ROL tmp_mix

    \ Channel 2 - inline phase accumulation
    LDA ch2_a
    ADC ch2_f
    STA ch2_a
    LDA ch2_a+1
    ADC ch2_f+1
    STA ch2_a+1
.ch2_noise_op
    NOP
    NOP
    ADC ch2_d
    ROL tmp_mix

    \ Channel 3 - inline phase accumulation
    LDA ch3_a
    ADC ch3_f
    STA ch3_a
    LDA ch3_a+1
    ADC ch3_f+1
    STA ch3_a+1
    ADC ch3_d
    ROL tmp_mix

    \ Channel 4 - inline phase accumulation
    LDA ch4_a
    ADC ch4_f
    STA ch4_a
    LDA ch4_a+1
    ADC ch4_f+1
    STA ch4_a+1
    ADC ch4_d
    ROL tmp_mix

    \ Volume calculation - use accumulated bit count
    LDA tmp_mix
    ADC #$0F
    TAX

    \ Tone volume decision - FIXED: inverted logic
    CPX #$10
    LDA #SN_LOUD            ; Assume loud
    BCS vol_set             ; If carry set (>=16), it's loud
    LDA #SN_MUTE            ; Otherwise mute
.vol_set
    TAY                     ; Y = tone volume

    \ Check if drum is active
    LDX drum_flag
    BEQ output_no_drum      ; No drum, just output tone
    
    \ Drum is active - check delay
    LDX drum_delay
    BEQ need_new_sample     ; Delay expired, get next sample
    
    \ Still in delay - decrement and output current state
    DEC drum_delay
    LDA drum_state
    JMP output_drum_mix
    
.need_new_sample
    \ Get next delay value from drum data
    LDX drum_flag
    DEX
    BEQ load_kick_sample
    DEX  
    BEQ load_hat_sample
    \ Invalid drum flag
    JMP output_no_drum
    
.load_kick_sample
    LDX drum_index
    CPX #16                 ; Kick is now 16 bytes
    BCS kick_finished
    LDA kick_data,X
    STA drum_delay
    INC drum_index
    \ XOR the drum state (alternating pattern)
    LDA drum_state
    EOR #$0F
    STA drum_state
    JMP output_drum_mix

.kick_finished
    LDA #0
    STA drum_flag
    STA drum_index
    \ Force mute state to avoid click when returning to tone
    LDA #SN_MUTE
    STA drum_state
    TYA                     ; Output tone only
    STA VIA_ORA
    LDA #0
    STA VIA_ORB
    LDA #8
    STA VIA_ORB
    JMP sample_decrement
    
.load_hat_sample
    LDX drum_index
    CPX #44                 ; Hat is now 44 bytes
    BCS hat_finished
    LDA hat_data,X
    STA drum_delay
    INC drum_index
    \ XOR the drum state (alternating pattern)
    LDA drum_state
    EOR #$0F
    STA drum_state
    JMP output_drum_mix

.hat_finished
    LDA #0
    STA drum_flag
    STA drum_index  
    \ Force mute state to avoid click when returning to tone
    LDA #SN_MUTE
    STA drum_state
    TYA                     ; Output tone only
    STA VIA_ORA
    LDA #0
    STA VIA_ORB
    LDA #8
    STA VIA_ORB
    JMP sample_decrement
    
\ Fast path - no drum, output tone only
.output_no_drum
    TYA                     ; Get tone volume
    STA VIA_ORA
    LDA #0
    STA VIA_ORB
    LDA #8
    STA VIA_ORB
    JMP sample_decrement
    
\ Mix drum and tone
.output_drum_mix
    STA ctrl_a              ; Save drum value
    
    \ If both tone and drum are loud, mix them
    CPY #SN_LOUD            ; Is tone loud?
    BNE use_drum_only       ; No, use drum only
    
    CMP #SN_LOUD            ; Is drum loud?
    BNE use_tone_only       ; No, use tone only
    
    \ Both loud - use mixed value
    LDA #$98
    JMP output_final
    
.use_drum_only
    LDA ctrl_a              ; Use drum value
    JMP output_final
    
.use_tone_only
    TYA                     ; Use tone value
    
.output_final
    STA VIA_ORA
    LDA #0
    STA VIA_ORB
    LDA #8
    STA VIA_ORB

\ Optimized sample counter decrement
.sample_decrement
    LDA sample_count
    BNE dec_lo
    DEC sample_count+1
.dec_lo
    DEC sample_count
    LDA sample_count
    ORA sample_count+1
    BEQ update_timer
    JMP synth_loop

.update_timer
    LDY #0
    INC ch1_e
    BNE e1
    INC ch1_e+1
.e1 
    LDA (ch1_e),Y
    CMP #$80
    BEQ e2
    STA ch1_d
.e2 
    INC ch2_e
    BNE e2_skip
    INC ch2_e+1
.e2_skip 
    LDA (ch2_e),Y
    CMP #$80
    BEQ e3
    STA ch2_d
.e3 
    INC ch3_e
    BNE e3_skip
    INC ch3_e+1
.e3_skip 
    LDA (ch3_e),Y
    CMP #$80
    BEQ e4
    STA ch3_d
.e4 
    INC ch4_e
    BNE e4_skip
    INC ch4_e+1
.e4_skip 
    LDA (ch4_e),Y
    CMP #$80
    BEQ slide_proc
    STA ch4_d

.slide_proc
    LDA ch4_s
    BEQ noslide
    LDA ch4_f+1
    LSR A
    TAX
    LDA ch4_f
    ROR A
    TAY
    SEC
    LDA ch4_f
    STY tmp_mix
    SBC tmp_mix
    STA ch4_f
    LDA ch4_f+1
    STX tmp_mix
    SBC tmp_mix
    STA ch4_f+1
.noslide
    DEC row_timer
    BNE play_same_row
    JMP check_row

.play_same_row
    LDA #SAMPLES_LO
    STA sample_count
    LDA #SAMPLES_HI
    STA sample_count+1
    CLC
    JMP synth_loop

.fetch_new_pattern
    LDY #0
    LDA (seq_ptr),Y
    STA pat_ptr
    INY
    LDA (seq_ptr),Y
    STA pat_ptr+1
    
    LDA pat_ptr
    ORA pat_ptr+1
    BNE fetch_done
    
    LDA music_data
    STA seq_ptr
    LDA music_data+1
    STA seq_ptr+1
    JMP fetch_new_pattern
.fetch_done
    RTS

\ FIXED: Kick drum - Z80 values divided by 8, ends cleanly
\ Z80: ds 4,#10 / ds 4,#20 / ds 4,#40 / ds 4,#80 / ds 4,0
\ Last section (ds 4,0) removed to avoid end squawk
.kick_data
    EQUB 2,2,2,2
    EQUB 4,4,4,4
    EQUB 8,8,8,8
    EQUB 16,16,16,16

\ FIXED: Hat - using first section of Z80 data, divided by ~5 for snappier sound
\ Original Z80 first section, scaled to preserve variation
.hat_data
    EQUB 3,1,2,1,2,4,1,2,1,3,2,3,1,2,2,1,1,3,3,4,1,1,3,1,2,1,2,4,1,2,1,3,2,3,1,2,2,1,1,3,3,4,1,1

.init_hw
    LDA #$9F
    JSR sn_w
    LDA #$BF
    JSR sn_w
    LDA #$DF
    JSR sn_w
    LDA #$FF
    JSR sn_w
    LDA #$FF
    STA VIA_DDRA
    LDA #$0F
    STA VIA_DDRB
    LDA #$81
    JSR sn_w
    LDA #$00
    JSR sn_w
    RTS
.sn_w
    STA VIA_ORA
    LDX #0
    STX VIA_ORB
    LDX #8
    STX VIA_ORB
    RTS

ORG $2000
    INCLUDE "tracks\Squeeker Plus\1-bit_high_and_rising.asm"
.end
SAVE "MAIN",start,end

SCREEN_START = &7c00

PRINT "-------------------------------------"
PRINT "    SQUEEKER PLUS - DRUMS FIXED      "
PRINT "-------------------------------------"
PRINT "CODE size    = ", ~end-start
PRINT "RAM FREE     = ", SCREEN_START-P%, "BYTES"
PRINT "Sample rate  = ", SAMPLES_PER_FRAME*50, "Hz"
PRINT "Kick length  = ", 16, "samples"
PRINT "Hat length   = ", 44, "samples"
PRINT "-------------------------------------"

PUTBASIC "loader.bas","LOADER"
PUTFILE  "BOOT","!BOOT",$ffff
PUTFILE  ".\bkgnd.bin", "UI", SCREEN_START