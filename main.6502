\ ******************************************************************
\ * SQUEEKER PLUS 6502 - FULL IMPLEMENTATION WITH DRUMS           *
\ * Ported from Utz's Z80 Engine / 1Tracker Shiru Version          *
\ ******************************************************************

\ --- Debug Flag ---
DEBUG = FALSE            \ Set to FALSE to disable debug output

\ --- Hardware Registers ---
VIA_ORA     = $FE41     \ Data
VIA_ORB     = $FE40     \ Control (PB3=WE)
SN_LOUD     = $90       \ Ch0 Vol 0
SN_MUTE     = $9F       \ Ch0 Vol 15

\ --- Timing Constants ---
SAMPLES_PER_FRAME = 200

\ --- Zero Page State ---
ORG 0
SKIP 112                \ Reserve 0-111 for system use

.seq_ptr     SKIP 2     \ Points to the list of patterns (the Song)
.row_timer   SKIP 1     \ Frame counter for current row
.sample_count SKIP 1    \ Samples remaining in current frame
.tmp_mix     SKIP 1
.ctrl_a      SKIP 1
.ctrl_b      SKIP 1
.pat_ptr     SKIP 2     \ Points to the actual notes (the Pattern)
.drum_flag   SKIP 1     \ Which drum to play (0=none, 1=kick, 2=hat)
.drum_ptr    SKIP 2     \ Drum sample data pointer
.drum_len    SKIP 1     \ Drum sample count
IF DEBUG
.debug_row   SKIP 1     \ Row counter for debug
ENDIF

\ Channel Blocks: 16-bit Freq, 16-bit Acc, 16-bit EnvPtr, 8-bit Duty
.ch1_f SKIP 2 : .ch1_a SKIP 2 : .ch1_e SKIP 2 : .ch1_d SKIP 1 : .ch1_n SKIP 1
.ch2_f SKIP 2 : .ch2_a SKIP 2 : .ch2_e SKIP 2 : .ch2_d SKIP 1 : .ch2_n SKIP 1
.ch3_f SKIP 2 : .ch3_a SKIP 2 : .ch3_e SKIP 2 : .ch3_d SKIP 1
.ch4_f SKIP 2 : .ch4_a SKIP 2 : .ch4_e SKIP 2 : .ch4_d SKIP 1 : .ch4_s SKIP 1

ORG $1100
.start
IF DEBUG
    LDA #22 : JSR $FFF4     \ Mode 7
    LDA #12 : JSR $FFF4     \ CLS
ENDIF
    
    SEI
    JSR init_hw
    
IF DEBUG
    LDA #0 : STA debug_row
ENDIF
    
    \ Start at the first pattern address in the sequence table (Offset +2)
    LDA #LO(music_data+2) : STA seq_ptr
    LDA #HI(music_data+2) : STA seq_ptr+1
    
    JSR fetch_new_pattern 
    JMP check_row

\ --- 1. SONG SEQUENCE LOGIC ---
.pattern_end
IF DEBUG
    LDA #'P' : JSR $FFEE
    LDA #'.' : JSR $FFEE
    LDA #'E' : JSR $FFEE
    LDA #'N' : JSR $FFEE
    LDA #'D' : JSR $FFEE
    LDA #' ' : JSR $FFEE
ENDIF
    
    LDA seq_ptr : CLC : ADC #2 : STA seq_ptr
    BCC p_next : INC seq_ptr+1
.p_next
    JSR fetch_new_pattern
    JMP check_row

\ --- 2. PATTERN READER ---
.check_row
IF DEBUG
    INC debug_row
    LDA debug_row : JSR print_hex
    LDA #':' : JSR $FFEE : LDA #' ' : JSR $FFEE
    LDA pat_ptr+1 : JSR print_hex
    LDA pat_ptr : JSR print_hex
    LDA #' ' : JSR $FFEE
ENDIF
    
    LDY #0
    LDA (pat_ptr),Y 
    
IF DEBUG
    JSR print_hex : LDA #' ' : JSR $FFEE
ENDIF
    
    INY
    CMP #$40
    BEQ pattern_end

.rdseq
    DEY                                   ; Back to Y=0
    LDA (pat_ptr),Y : INY                 ; Low byte (flags)
    STA ctrl_a
    LDA (pat_ptr),Y : INY                 ; High byte (SPEED)
    STA row_timer                         ; Number of frames to play this row
    
IF DEBUG
    LDA row_timer : JSR print_hex
    LDA #13 : JSR $FFEE
ENDIF
    
    LDA (pat_ptr),Y : STA ch2_n : INY     ; Noise low
    LDA (pat_ptr),Y : STA ch1_n : INY     ; Noise high

    \ --- Channel 1 Update ---
    LDA ctrl_a : LSR A : BCS ld2
    LDA (pat_ptr),Y : STA ch1_f : INY
    LDA (pat_ptr),Y : STA ch1_f+1 : INY
    LDA (pat_ptr),Y : STA ch1_e : INY
    LDA (pat_ptr),Y : STA ch1_e+1 : INY
    LDA #0 : STA ch1_a : STA ch1_a+1
    STY tmp_mix : LDY #0 : LDA (ch1_e),Y : STA ch1_d : LDY tmp_mix
.ld2
    \ --- Channel 2 Update ---
    LDA ctrl_a : AND #4 : BNE ld3
    LDA (pat_ptr),Y : STA ch2_f : INY
    LDA (pat_ptr),Y : STA ch2_f+1 : INY
    LDA (pat_ptr),Y : STA ch2_e : INY
    LDA (pat_ptr),Y : STA ch2_e+1 : INY
    LDA #0 : STA ch2_a : STA ch2_a+1
    STY tmp_mix : LDY #0 : LDA (ch2_e),Y : STA ch2_d : LDY tmp_mix
.ld3
    \ --- Channel 3 Update ---
    BIT ctrl_a : BMI ld4
    LDA (pat_ptr),Y : STA ch3_f : INY
    LDA (pat_ptr),Y : STA ch3_f+1 : INY
    LDA (pat_ptr),Y : STA ch3_e : INY
    LDA (pat_ptr),Y : STA ch3_e+1 : INY
    LDA #0 : STA ch3_a : STA ch3_a+1
    STY tmp_mix : LDY #0 : LDA (ch3_e),Y : STA ch3_d : LDY tmp_mix
.ld4
    \ --- Channel 4 Update & DRUM CHECK ---
    LDA (pat_ptr),Y : STA ctrl_b : INY    ; Low byte of control word B
    INY                                    ; Skip high byte (always 0)
    
    \ Check for drums (bit 2 = kick, bit 7 = hat)
    LDA #0 : STA drum_flag
    LDA ctrl_b : AND #$04 : BEQ no_kick
    LDA #1 : STA drum_flag
.no_kick
    LDA ctrl_b : AND #$80 : BEQ no_hat
    LDA #2 : STA drum_flag
.no_hat
    
    LDA ctrl_b : AND #$40 : BNE skip4
    LDA (pat_ptr),Y : STA ch4_f : INY
    LDA (pat_ptr),Y : STA ch4_f+1 : INY
    LDA (pat_ptr),Y : STA ch4_e : INY
    LDA (pat_ptr),Y : STA ch4_e+1 : INY
    LDA #0 : STA ch4_a : STA ch4_a+1
    STY tmp_mix : LDY #0 : LDA (ch4_e),Y : STA ch4_d : LDY tmp_mix
.skip4
    LDA ctrl_b : AND #1 : STA ch4_s

    \ --- Advance Pattern Pointer ---
    TYA : CLC : ADC pat_ptr : STA pat_ptr
    BCC p_adv : INC pat_ptr+1
.p_adv
    \ Setup frame and check for drums
    LDA #SAMPLES_PER_FRAME : STA sample_count
    
    \ Check if drum needs to be played (only once per row)
    LDA drum_flag : BEQ synth_loop
    CMP #1 : BEQ play_kick_now
    CMP #2 : BEQ play_hat_now
    JMP synth_loop
    
.play_kick_now
    LDA #0 : STA drum_flag      ; Clear flag
    LDA #LO(kick_data) : STA drum_ptr
    LDA #HI(kick_data) : STA drum_ptr+1
    LDA #20 : STA drum_len
    JSR drum_player
    JMP synth_loop              ; Continue with tone synthesis
    
.play_hat_now
    LDA #0 : STA drum_flag      ; Clear flag
    LDA #LO(hat_data) : STA drum_ptr
    LDA #HI(hat_data) : STA drum_ptr+1
    LDA #175 : STA drum_len
    JSR drum_player
    JMP synth_loop              ; Continue with tone synthesis

\ --- 3. DRUM PLAYER ---
.drum_player
    LDY #0
    LDA #SN_MUTE            ; Start with mute state
.drum_outer
    EOR #$0F                ; Toggle between MUTE ($9F) and LOUD ($90)
    STA tmp_mix             ; Save output state
    LDA (drum_ptr),Y        ; Get delay count for this sample
    TAX                     ; X = delay count
    INY
.drum_inner
    LDA tmp_mix             ; Get output state
    STA VIA_ORA
    LDA #0 : STA VIA_ORB : LDA #8 : STA VIA_ORB
    DEX                     ; Decrement delay counter
    BNE drum_inner
    LDA tmp_mix             ; Restore output state for next toggle
    DEC drum_len            ; Next drum sample
    BNE drum_outer
    
    \ Drum done, return to caller
    RTS

\ --- 4. CYCLE-TIMED SYNTHESIS LOOP ---
.synth_loop
    \ Generate one sample by mixing all 4 channels
    \ Z80: add duty to high byte, rotate carry into accumulator
    
    LDA #0 : STA tmp_mix        ; Clear mixing accumulator (C register)
    
    \ Channel 1: Z80 does "add a,h : rl c"
    CLC : LDA ch1_a : ADC ch1_f : STA ch1_a
    LDA ch1_a+1 : ADC ch1_f+1 : STA ch1_a+1
    
    \ Apply noise mode if enabled
    LDX ch1_n : BEQ skip_n1
    ROR ch1_a+1
.skip_n1
    \ Z80: add a,h (A = duty + high byte)
    \ This sets carry if result > 255
    CLC
    ADC ch1_d                   ; A = ch1_a+1 + duty
    \ Carry is now set if waveform should be high
    ROL tmp_mix                 ; Rotate carry into tmp_mix

    \ Channel 2
    CLC : LDA ch2_a : ADC ch2_f : STA ch2_a
    LDA ch2_a+1 : ADC ch2_f+1 : STA ch2_a+1
    
    LDX ch2_n : BEQ skip_n2
    ROR ch2_a+1
.skip_n2
    CLC
    ADC ch2_d
    ROL tmp_mix

    \ Channel 3
    CLC : LDA ch3_a : ADC ch3_f : STA ch3_a
    LDA ch3_a+1 : ADC ch3_f+1 : STA ch3_a+1
    CLC
    ADC ch3_d
    ROL tmp_mix

    \ Channel 4
    CLC : LDA ch4_a : ADC ch4_f : STA ch4_a
    LDA ch4_a+1 : ADC ch4_f+1 : STA ch4_a+1
    CLC
    ADC ch4_d
    ROL tmp_mix                 ; Now tmp_mix has 4 bits
    
    \ Final mix: Z80 does "ld a,#f : adc a,c"
    CLC
    LDA #$0F
    ADC tmp_mix
    
    \ Check for sound output
    CMP #$10
    BCS do_loud
    
    LDA #SN_MUTE
    JMP send_sn
.do_loud
    LDA #SN_LOUD
.send_sn
    STA VIA_ORA : LDX #0 : STX VIA_ORB : LDX #8 : STX VIA_ORB

    \ Brief settling delay
    NOP : NOP : NOP : NOP
    
    \ Check if frame complete
    DEC sample_count
    BNE synth_loop
    
    \ Frame complete - update envelopes
    JMP update_timer

\ --- 5. ENVELOPE & SLIDE UPDATE ---
.update_timer
    INC ch1_e : BNE e1 : INC ch1_e+1
.e1 LDY #0 : LDA (ch1_e),Y : CMP #$80 : BEQ e2 : STA ch1_d
.e2 INC ch2_e : BNE e2_skip : INC ch2_e+1
.e2_skip LDY #0 : LDA (ch2_e),Y : CMP #$80 : BEQ e3 : STA ch2_d
.e3 INC ch3_e : BNE e3_skip : INC ch3_e+1
.e3_skip LDY #0 : LDA (ch3_e),Y : CMP #$80 : BEQ e4 : STA ch3_d
.e4 INC ch4_e : BNE e4_skip : INC ch4_e+1
.e4_skip LDY #0 : LDA (ch4_e),Y : CMP #$80 : BEQ slide_proc : STA ch4_d

.slide_proc
    LDA ch4_s : BEQ noslide
    LDA ch4_f+1 : LSR A : TAX
    LDA ch4_f   : ROR A : TAY
    SEC : LDA ch4_f : STY tmp_mix : SBC tmp_mix : STA ch4_f
    LDA ch4_f+1 : STX tmp_mix : SBC tmp_mix : STA ch4_f+1
.noslide
    DEC row_timer
    BNE play_same_row
    JMP check_row

.play_same_row
    LDA #SAMPLES_PER_FRAME : STA sample_count
    JMP synth_loop

.fetch_new_pattern
    LDY #0
    LDA (seq_ptr),Y : STA pat_ptr
    INY
    LDA (seq_ptr),Y : STA pat_ptr+1
    
    LDA pat_ptr : ORA pat_ptr+1 : BNE fetch_done
    
IF DEBUG
    LDA #'L' : JSR $FFEE : LDA #'O' : JSR $FFEE
    LDA #'O' : JSR $FFEE : LDA #'P' : JSR $FFEE
    LDA #13 : JSR $FFEE
    LDA #0 : STA debug_row
ENDIF
    
    LDA music_data : STA seq_ptr
    LDA music_data+1 : STA seq_ptr+1
    JMP fetch_new_pattern
.fetch_done
    RTS

\ --- DRUM SAMPLE DATA ---
\ Kick: expanding periods for bass drum effect
.kick_data
    EQUB 16,16,16,16,32,32,32,32,64,64,64,64,128,128,128,128,0,0,0,0

\ Hat: hi-hat noise pattern (175 bytes from Z80 version)
.hat_data
    EQUB 16,3,12,6,9,20,4,8,2,14,9,17,5,8,12,4,7,16,13,22,5,3,16,3,12,6,9,20,4,8,2,14,9,17,5,8,12,4,7,16,13,22,5,3
    EQUB 12,8,1,24,6,7,4,9,18,12,8,3,11,7,5,8,3,17,9,15,22,6,5,8,11,13,4,8,12,9,2,4,7,8,12,6,7,4,19,22,1,9,6,27,4,3,11
    EQUB 5,8,14,2,11,13,5,9,2,17,10,3,7,19,4,3,8,2,9,11,4,17,6,4,9,14,2,22,8,4,19,2,3,5,11,1,16,20,4,7
    EQUB 8,9,4,12,2,8,14,3,7,7,13,9,15,1,8,4,17,3,22,4,8,11,4,21,9,6,12,4,3,8,7,17,5,9,2,11,17,4,9,3,2
    EQUB 22,4,7,3,8,9,4,11,8,5,9,2,6,2,8,8,3,11,5,3,9,6,7,4,8

IF DEBUG
.print_hex
    PHA
    LSR A : LSR A : LSR A : LSR A
    CMP #10 : BCC ph1 : ADC #6
.ph1 ADC #'0' : JSR $FFEE
    PLA : AND #15
    CMP #10 : BCC ph2 : ADC #6
.ph2 ADC #'0' : JSR $FFEE
    RTS
ENDIF

.init_hw
    LDA #$9F : JSR sn_w : LDA #$BF : JSR sn_w
    LDA #$DF : JSR sn_w : LDA #$FF : JSR sn_w
    LDA #$FF : STA $FE43 : LDA #$0F : STA $FE42
    LDA #$81 : JSR sn_w : LDA #$00 : JSR sn_w : RTS
.sn_w
    STA VIA_ORA : LDX #0 : STX VIA_ORB : LDX #8 : STX VIA_ORB : RTS

ORG $2000
    INCLUDE "tracks\Squeeker Plus\1-bit_high_and_rising.asm"
.end
SAVE "MAIN",start,end

PRINT "-------------------------------------"
PRINT "      1-BIT SQUEEKER PLUS PLAYER     "
PRINT "-------------------------------------"
PRINT "CODE size       = ", ~end-start
PRINT "HIGH WATERMARK  = ", ~P%
PRINT "FREE            = ", ~start+end
PRINT "-------------------------------------"

PUTBASIC "loader.bas","LOADER"
PUTFILE  "screens\title.bin","TITLE",&7c00
PUTFILE  "BOOT","!BOOT",$ffff